# ReplaceHexPatcher - Документация

Language: Русский | [English](docs.md)

- [ReplaceHexPatcher - Документация](#replacehexpatcher---документация)
  - [Предисловие](#предисловие)
  - [Основа (Core)](#основа-core)
  - [Обертки (Wrappers)](#обертки-wrappers)
    - [Скрипт-обертка "data inside"](#скрипт-обертка-data-inside)
    - [Скрипт-обертка "data in template"](#скрипт-обертка-data-in-template)
      - [Шаблон template.txt](#шаблон-templatetxt)
        - [Структура шаблона](#структура-шаблона)
          - [Секции](#секции)
          - [Комментарии](#комментарии)
          - [Глобальные переменные](#глобальные-переменные)
          - [Текст вне секций](#текст-вне-секций)
      - [Последовательность действий в парсере](#последовательность-действий-в-парсере)
        - [Секции (подробно)](#секции-подробно)
          - [Флаги:](#флаги)
  - [Известные ограничения](#известные-ограничения)
  - [Тестирование](#тестирование)
  - [Утилиты](#утилиты)
  - [Ответы на возможные вопросы](#ответы-на-возможные-вопросы)


## Предисловие

Изначально я преследовал цель создать 2х-кликовое нативное для Windows решение для поиска и замены байт как это умеют делать утилиты `perl` и `sed` в macOS и GNU Linux.

То есть для решения поставленной задачи (поиска и замены байт) необходимо использовать только то что есть в Windows сразу после установки. Никаких сторонних файлов/программ скачиваться и применяться не должно.

В Windows предустановлены 4 "интерпретатора кода" - CMD, Visual Basic Script, Powershell, JavaScript.
CMD слишком ограничен в возможностях. В Visual Basic Script я не нашел способа написать эффективный код для поиска и замены шаблона байт в файле любого объема. А вот Powershell это, очень грубо говоря, среда выполнения кода C#, а с помощью C# можно делать очень многие вещи и поэтому с помощью кода на Powershell вполне можно выполнить поиск и замену байт в hex формате.

Я начал искать способы сделать это на Powershell и сначала нашел [этот](https://stackoverflow.com/a/57339359) пример, но, если я правильно помню, такой поиск и замена байт работали у меня медленно. Других примеров я не смог найти и обратился к ChatGPT и он сгенерировал для меня необходимый скрипт. Я его протестировал и улучшил и написал дополнительные скрипты-обертки.

Конечно интерпретируемый код работает медленнее чем скомпилированные утилиты для данных задач, но, возможно если такие утилиты написанные на C# ([HexAndReplace](https://github.com/jjxtra/HexAndReplace) или [BinaryFilePatcher](https://github.com/Invertex/BinaryFilePatcher)) переписать на Powershell то это улучшит код и скорость его выполнения (но это не точно)

## Основа (Core)

Основу (ядро) данного инструмента составляет Powershell-скрипт [ReplaceHexBytesAll.ps1](../core/ReplaceHexBytesAll.ps1), который находится в папке "core". Он как раз и выполняет функцию поиска + замены байт и вывода небольшого отчета о том все ли шаблоны были заменены или какие-то шаблоны не найдены.

Но если быть более точным, то функцию поиска и замены байт выполняет C#-код в скрипте. Этот C#-код компилируется и подключается/импортируется в качестве модуля к текущей сессии Powershell и при повторных запусках скрипта - время на компиляцию не тратится.

Скрипт принимает 3 аргумента:
1. `-filePath` - путь к файлу в котором необходимо выполнить поиск и замену байт, указывается после аргумента
2. `-patterns` - hex-шаблоны для поиска и замены байт в виде массива или 1 строкой, указывается после аргумента
3. `-makeBackup` - если необходимо создать бэкап оригинального файла

Подробнее:

1. Путь к файлу

С путем к файлу все очевидно. Путь к файлу-цели в котором будет производится поиск и замена байт. Если ни один паттерн байт не будет найден файл не будет никак затронут.

Путь к файлу передается как аргумент запуска скрипта `-filePath "D:\path\to\file.exe"`

2. Hex-паттерны

Шаблоны для поиска + замены байт в hex-формате. Паттерны для поиска и паттерны для замены байт пишутся в 1 строке и разделаются одним из символов `/` или `\` или `|`.

Важно только чтобы паттерны содержали hex-символы (то есть состояли из цифр `0-9` и букв `a-f` включительно и без учета регистра). А также подстановочные символы `??` (количество знаков вопроса должно быть кратно 2).
Сами паттерны не имеют строго формата. Между значениями в паттерне может быть любое количество пробелов и символов `\x` - все они удалятся (их наличие не вызовет ошибок).

То есть все эти форматы валидные - `AABBСС/112233`, `AA    BB CC/1 122 3 3`, `\xAA\xBB \xCC/1122\x33`,`??1FBA0E??????CD21B8014CCD21????/????????????????74C3????????????`

Подстановочные знаки `??` можно использовать в hex-паттернах и поиска и замены, но паттерны не могут состоять только из этих знаков (это бессмысленно).

Подстановочный знак `??` в паттерне поиска означает, что на его месте может быть любой байт. Например паттерн `00AABBCC??/1122334455` означает, что последовательности `00AABBCC00`,`00AABBCC11` и все, вплоть до `00AABBCCFF` будут считаться валидными и будут заменены байтами из паттерна замены. Если возможно выполнить патч без использования подстановочных символов `??` - то лучше их не использовать, потому что они увеличивают количество вариантов поиска, что снижает производительность и, соответственно, увеличивает время поиска. Подстановочные знаки в начале паттерна поиска, наверное, имеет смысл использовать только, если замену байт нужно выполнить в самом начале файла с определенным отступом.

Подстановочный знак `??` в паттерне замены означает, что на его месте будет использоваться оригинальный байт из файла. Например при паттерны `00AABBCCDDFF/00AAC3CCDDFF` и `00AABBCCDDFF/????C3??????` являются идентичными в данном случае.

Все наборы паттернов передаются после указания аргумента запуска скрипта `-patterns`.
Их можно передавать как массив строк через запятую `"AABB/1122","CCDD/4455"`, так и в виде 1 большой строки `"AABB/1122,CCDD/4455"`. Такая вариативность сделана в первую очередь потому что если запускать скрипт из другого Powershell-скрипта через `Start-Process`, то передаваемые через запятую строки не распознаются как массив.

3. Бэкап патченного файла

Передав параметр `-makeBackup` оригинальный файл (цель) будет скопирован в ту же папку где он находился и к его полному имени будет добавлен текст `.bak`. Все атрибуты оригинального файла будут перенесены на забэкапленный файл, как и разрешения и параметры NTFS.

Бэкап будет сделан только если у файла будет найден хотя бы один паттерн.
Если паттерны найдены не будут, соответственно цель никак не будет изменена и в бэкапе нет смысла.

Вообще "под капотом" бэкап делается изначально в уникальный временный файл в той же папке перед началом поиска байт. Потому что когда мы начнем чтение файла то при нахождении нужных паттернов они будут сразу же заменены. Нет возможности сделать бэкап только при нахождении и замене первого паттерна байт, потому что файл доступ к файлу будет заблокирован на время чтения. В случае если паттерны будут найдены и, соответственно, файл-цель будет изменена, то временный бэкап-файл будет переименован в "истинный" бэкап файл (тот, что с расширением `.bak`) и если такой файл-бэкап существовал до модификации файла-цели, то существующий файл-бэкап будет удален.

---

Чтобы воспользоваться скриптом, необходимо:
1. Запустить Powershell
2. С помощью `cd <путь>` перейти в папку с файлом `ReplaceHexBytesAll.ps1`
3. В окне Powershell выполнить:
```
.\ReplaceHexBytesAll.ps1 -filePath "D:\TEMP\file.exe" -patterns "48 83EC2 8BA2F 000000 488A/202 0EB1 1111 11111 111111","C42518488D4D68\90909011111175","45A8488D55A8|75EB88909090","\xAA\x7F\xBB\x08\xE3\x4D|\xBB\x90\xB1\xE8\x99\x4D","??1FBA0E??????CD21B8014CCD21????/????????????????74C3????????????" -makeBackup
```

Вот другие примеры валидных команд:
```
.\ReplaceHexBytesAll.ps1 -filePath "D:\TEMP\test\test.exe" -patterns "AABBCC/112233","44aa55\66bb77","1234|5678","????2600000FB6D8488D4C2440FF1578/EB032600000FB6D8488D4C2440FF1578"
```

```
.\ReplaceHexBytesAll.ps1 -filePath "D:\TEMP\file.exe" -patterns "4883EC28BA2F000000488A/2020EB1 111111111111111,C42518488D4D68/90909011111175,45A8488D55A8/75EB88909090,AA7FBB08E34D/BB90B1E8994D"
```


## Обертки (Wrappers)

Основной скрипт выполняет только поиск и замену байт в 1 файле. А что если необходимо сделать это для нескольких файлов? А также создать один или несколько файлов с текстом или заблокировать к файлам доступ в сеть с помощью фаервола?

Все эти дополнительные действия (сайдэффекты) можно сделать с помощью дополнительного кода, который я написал в отдельных скриптах. Эти скрипты формируют команды для запуска основного скрипта-патчер с динамически сформированными аргументами, а также выполняют дополнительные действия.

Есть 2 типа скриптов-оберток:
1. Данные внутри скрипта (data inside)
2. Данные из шаблона (data in template)


### Скрипт-обертка "data inside"

Этот скрипт написан на CMD с небольшим добавлением Powershell кода там где без него не обойтись. В этом типе скрипта все необходимые - пути или ссылки на "ядро", пути к файлам-целям для модификаций, все паттерны для поиска и замены, текст для hosts и для других файлов - все это находится внутри скрипта `Start.cmd`

Прежде чем запускать скрипт - его нужно настроить. Нужно внести данные с которыми он будет работать - добавить паттерны, пути к файлам для модификаций и т.д. - все это вручную с помощью изменения существующих переменных и добавления новых переменных.
Я старался написать скрипт так, чтобы добавление и изменение этих переменных было простым действием и делалось в минимальном количестве мест в коде (только в блоке кода "MAIN").

Для удобства внутрь скрипта добавлен чек-лист того что нужно проверить перед тем как считать его готовым.

1. Файлы-цели для патча
    - Если необходимо пропатчить несколько файлов (файлов-целей), то необходимо в переменную `count_target_files` вписать количество файлов для патча
    - Путь к каждому файлу поместить в переменные `target_path_1` и последняя цифра переменной должна быть уникальным последовательным индексом
2. Патчи - паттерны для поика+замены байт для файлов-целей
    - В переменную `count_patches_f1` необходимо вписать количество паттернов для поиска+замены байт. Последняя цифра в переменной означает индекс файла-цели для которого необходимо применить паттерны. Если файлов-целей несколько, то необходимо создать несколько таких переменных изменив индексы в их название на индексы соответствующие файлам-целям
    - Создать переменные `original_f1_1` и `patched_f1_1` в которых необходимо хранить hex-паттерны для поиска и замены байт соответственно. Для 1 hex-паттерна 1 переменная и если паттернов несколько - в новых переменных увеличить последнее число-индекс на 1. Текст `f1` означает индекс файла для которого предназначается паттерн
    - TODO: возможно лучше переделать скрипт, чтобы паттерны поиска+замены записывать не в разные переменные, а в 1 переменную, например `"pattern_f1_1=AABBCC/112233"`
3. Создание текстовых файлов
    - Если текстовые файлы создавать не нужно - закомментировать строку `call :create_all_text_files`
    - Если необходимо создать только 1 текстовый файл, то
      - в переменную `file_text_path_1` - поместить полный путь к текстовому файлу
      - в переменную `endline_text_file_1` вписать тип окончания строки (CRLF или LF)
      - в переменную `create_mode_text_file_1` вписать "режим создания" файла - FORCE или NOTOVERWRITE. При режиме FORCE файл будет перезаписан если такой файл существует, а при режиме NOTOVERWRITE файл не будет затронут/перезаписан, если он уже существует
      - внутри функции `:create_text_file_1` вписать текст который необходимо поместить в файл
    - Если необходимо создать несколько текстовых файлов, то создать несколько вышеперечисленных переменных под каждый файл и увеличить число-индекс в конце переменной
      - А также для каждого файла создать функцию `:create_text_file_1` с индивидуальным текстом для содержания файла (ну и число-индекс в названии функции тоже увеличить)
4. Добавление строк в hosts
    - Если в файл hosts ничего не нужно добавлять - закомментировать строку `call :block_hosts "NOTOVERWRITE" "WRITE HERE NAME OF GROUP FILES ADDED TO HOSTS"`
    - Если в файл hosts нужно добавить какие-то строки, то сами URL-адреса для блокировки добавить внутрь функции `:block_hosts`, при выполнении скрипта функция сама сформирует строки и добавит их в hosts, если таких строк раньше не было
      - Также в строку вызова функции `call :block_hosts "NOTOVERWRITE" "WRITE HERE NAME OF GROUP FILES ADDED TO HOSTS"` первым аргументом добавить слово "FORCE" или "NOTOVERWRITE". "FORCE" означает тупо добавить строки в конец hosts, а "NOTOVERWRITE" означает не добавлять их если точно такой же набор строк с таким же названием группы есть в конце файла
      - Ну а вместо "WRITE HERE NAME OF GROUP FILES ADDED TO HOSTS" написать название/заголовок для группы строк, например "Adobe servers"
5. Блокировка файлов-целей с помощью Windows Firewall
    - Если файлы-цели не нужно блокировать с помощью фаервола, то закомментировать строку `call :block_targets_with_firewall`, иначе оставить эту строку без изменений

Возможно было бы логичнее часть функционала вынести в отдельные файлы-скрипты, но я хотел сделать максимально "монолитное" 2-кликовое решение. 


### Скрипт-обертка "data in template"

Во втором решении лезть внутрь скрипта не нужно, все данные для работы берутся из файла `template.txt`. Название и расширение файла может быть любым, но в нем будут хранится текстовые данные. Этот шаблон парсится соответствующим скриптом - `Parser.ps1` и при наличии блока информации с путями + паттернами - парсер вызывает скрипт `ReplaceHexBytesAll.ps1` и заранее динамически формирует и аргументы перед вызовом ядра. Также скрипт-парсер выполняет дополнительные действия в зависимости от наполнения файла `template.txt` - добавляет или удаляет строки из `hosts`, добавляет или удаляет файлы и т.д.

Парсер принимает 1 аргумент - `-template <строка>`. Шаблон может быть предоставлен в 3 видах:
- путь к файлу на диске
- ссылка на файл
- непосредственно шаблон в виде многострочного текста

В каждом из вариантов текст-шаблон может быть как в виде "исходного" текста, так и в виде base64-кода.

Вот пример запуска парсера из Powershell:
```
.\Parser.ps1 -templatePath "C:\Users\Public\template.txt"
```
или просто
```
.\Parser.ps1 https://pastebin.com/raw/123qwe456
```
или
```
.\Parser.ps1 'многострочный
текст
самого
шаблона
'
```


В той же папке есть `Start.cmd` - это обертка над `Parser.ps1` чтобы парсер можно было запустить двойным кликом, а не открывать сначала Powershell и переходить в папку с парсером.
В этом скрипте-обертке можно заранее указать полный путь (или URL) к парсеру и к `template.txt` и к патчеру в соответствущих переменных `parser_path`, `template_path`, `patcher_path` и тогда парсер запустится вместе с этими аргументами.

Если пути (или URL) не указать, тогда будет производится сначала поиск парсера (файла с именем `Parser.ps1`) сначала в текущей папке, если там его не будет то парсер будет скачан по прямой ссылке из текущего репозитория и путь к скачанному файлу и будет являться путем к парсеру.
Потом такая же процедура поиска будет по отношению к файлу `template.txt`. А к путь (или URL) к патчеру нужно указывать вручную, иначе он не будет передан (и будут использованы пути из файла-шаблона).

---

Изначально весь код был написан в 1 файле `Parser.ps1`, он содержал более 1500 строк и был не парсером шаблона, а мульти-инструментом, который после разбора шаблона "дергает за ниточки" другие функции, в зависимости от секций, находящихся в шаблоне. Файл с кодом 1500 строк не удобно обслуживать и далеко не все функции могут быть нужны, все зависит от шаблона. Поэтому я вынес весь основной функционал, который "дергается за ниточки" в отдельные Powershell-файлы и они импортируются или скачиваются по мере необходимости через dot sourcing. Эти файлы как-бы библиотеки, которые подключаются к основному файлу.

Файл `Parser.ps1` так и остался мульти-инструментом, но теперь он содержит меньше кода, что улучшило читаемость.

Я оставил вариант этого файла, где весь код находится внутри, в отдельной папке, но не стоит его использовать, потому что он оставлен просто как пример и его функционал не дорабатывается. Его доработка/адаптация/синхронизация по сравнению с версией разделенной на части будет производится "по наитию".

#### Шаблон template.txt

Теперь о шаблоне. Структура шаблона была сделана так, чтобы данные можно было легко заполнять вручную обычным Ctrl+C и Ctrl+V, поэтому шаблоны данных в формате `.json` и `.xml` не подходят, потому что при их заполнении легко ошибиться и нарушить структуру-синтаксис.

##### Структура шаблона

- секции
- комментарии
- глобальные переменные
- содержимое вне секций

###### Секции

В шаблоне могут располагаться разные данные и каждый тип данных должен располагаться в своей секции. Секции отделяются строками, которые содержат следующий текст

- `[start-НАЗВАНИЕ_СЕКЦИИ]` - строка начало секции
- `[end-НАЗВАНИЕ_СЕКЦИИ]` - строка конец секции
- все что между этими строками (то есть внутри секции) - данные секции и будут анализироваться парсером в зависимости от названия секции
- все что не внутри какой-либо секции - не будет никак анализироваться, по сути можно считать это комментариями к шаблону и секциям и вну секций можно писать все что угодно
- секции могут быть расположены в любой последовательности, это не повлияет на очередность их анализа. Очередность задана в области MAIN в парсере

Есть во такие секции, подробнее о каждой будет дальше

- `flags`
- `variables`
- `pre_powershell_code`
- `pre_cmd_code`
- `patch_bin`
- `patch_text`
- `file_create_from_text`
- `file_create_from_base64`
- `hosts_add`
- `hosts_remove`
- `files_or_folders_delete`
- `firewall_block`
- `firewall_remove_block`
- `registry_file`
- `post_powershell_code`
- `post_cmd_code`

###### Комментарии

Все что не внутри какой-либо секции - не будет никак анализироваться, по сути можно считать это комментариями к шаблону и секциям и вну секций можно писать все что угодно

Внутри секций тоже могут быть комментарии. Все строки содержащие этот текст:
- `;;`
- `#`

считаются комментариями и будут удалены перед дальнейшим анализом

###### Глобальные переменные

При указании путей к файлам в путях может встречаться динамические данные, которые зависят от "настроек" системы - имя пользователя. Поэтому я принял решение некоторые слова сделать в качестве глобальных переменных для всего текста во всех секциях шаблона:
- `$USER` и `USERNAME_FIELD` будут заменены на имя текущего пользователя Windows
- `USERPROFILE_FIELD` и `USERHOME_FIELD` будут заменены на путь к домашней папке - путь к папке пользователя Windows

###### Текст вне секций

Все, что находится снаружи секций - никак не учитывается и не анализируется. Поэтому промежутки между секций можно использовать как область с комментариями/заметками/документацией. Особенно это актуально, если у вас много hex-паттернов.

Также это дает определенную возможность сокрытия/обфускации шаблона от разнообразных "автоматических анализаторов". Можно секции шаблона положить/внедрить в большой текстовый файл, чтобы уменьшить подозрения, что текст как-то связан с модификацией файлов.

Но сокрытие данных не являлось целью или шагом при создании утилиты. Просто я придерживался стратегии, что не должно быть строгой структуры данных у шаблона, чтобы можно было вручную в любом текстовом редакторе положить строки с путями и паттернами...


#### Последовательность действий в парсере

1. Поиск и замена всех глобальных переменных в шаблоне
2. Проверка наличия секций `hosts_remove`, `hosts_add`, `firewall_block`, `firewall_remove_block`, `registry_file`. Если такие секции есть и парсер запущен не от имени Администратора - перезапускаем парсер с полученными аргументами от имени Администратора, потому что при использовании данных из этих секций 100% понадобятся права админа и чтобы при обработке данных из каждой секции не запрашивать эти права в отдельных процессах - удобнее перезапустить скрипт с нужными правами с самого начала.
3. Поиск секций и извлечение данных из них в такой очередности
    1. `flags`
    2. `variables`
    3. `pre_powershell_code`
    4. `pre_cmd_code`
    5. `patch_bin`
    6. `patch_text`
    7. `hosts_remove`
    8. `hosts_add`
    9.  `files_or_folders_delete`
    10. `file_create_from_text`
    11. `file_create_from_base64`
    12. `firewall_remove_block`
    13. `firewall_block`
    14. `registry_file`
    15. `post_powershell_code`
    16. `post_cmd_code`
4. Будет использована первая найденная секция каждого типа, если у одного типа (например `hosts_add`) несколько секций в шаблоне - все последующие секции этого типа, кроме первой сверху - не будут использоваться.
    - Исключением являются секции `file_create_from_text` и `file_create_from_base64`, потому что при необходимости создания нескольких файлов - необходимо разместить несколько таких секций
5. При использовании данных извлеченных из каждой секции производится сначала "очистка" данных - `Trim()` по для блока с всем текстом секции, а потом поиск и замена переменных из секции `variables`
    - Исключением являются секции `file_create_from_text` и `file_create_from_base64` - для них производится не `Trim()`, а `TrimStart()`, то есть удаление "пустот" вначале текста. Это сделано для того, чтобы если в создаваемом тексте должны быть пустые строки в конце - чтобы они не удалились из контента секции
    - Все окончания строк извлеченного из шаблона текста приводятся к типу `LF`, то есть `\n` для удобства обработки. Это не влияет на тип окончания строк в создаваемых файлах, потому что это значение можно задать вручную в соответствующих секциях 
6. Далее в зависимости от типа секции данных используются соответствующим образом (об этом подробнее в информации о каждой секции)
7. Если скрипт не имеет права Администратора, но для совершения действий требуются права Администратора - будет сформирована Powershell-команда и запущена в отдельном процессе с запросом прав админа
    - Исключением являются секции `firewall_remove_block` и `firewall_block` - если не будет прав администратора они выдадут ошибки
8. В каждой секции данные считываются и обрабатываются построчно
9. После работы парсера удаляются все временные файлы, отображается длительность работы парсера и строка `Press any key to continue...`, далее нажав на любую клавишу он закрывается.


##### Секции (подробно)

1. `flags`

Здесь располагаются флаги-ключи для некоторой настройки поведения патчера, в частности для работы с секциями `patch_bin` и `patch_text`.

Каждый флаг должен быть написан на новой строке. Флаги можно дублировать, писать в любом порядке и указывать вообще любой текст - ошибок не будет. В конечном итоге останутся и будут использованы только валидные флаги (для работы которых написан соответствующий код).

---

###### Флаги:

1. `MAKE_BACKUPS`
   - создавать бэкап-файлы для патченных бинарных и текстовых файлов из секций `patch_bin` и `patch_text`
   - если выполняется режим поиска и замены паттернов байт (а не просто поиска), то для файлов из секций `patch_bin` и `patch_text` у которых найдены паттерны поиска - создаются файлы с расширением .bak перед модификацией (до того как произойдет вставка паттернов замены)
   - если файлы с расширением .bak уже существуют - они будут перезаписаны
2. `REMOVE_SIGN_PATCHED_PE`
   - удалить подпись у патченных бинарных файлов из секции `patch_bin`, предварительно проверив, что патченный файл является PE-файлом
3. `CAN_USE_REGEXP_IN_PATCH_TEXT`
   - все текста/строки/паттерны поиска в секции `patch_text` рассматриваются как регулярные выражения
4. `PATCH_TEXT_IS_CASEINSENSITIVE`
   - используется регистронезависимый поиск для текста/строк/паттернов в секции `patch_text`
5. `WILDCARD_IS_1_Q_SYMBOL`
   - указывает, что wildcard это 1 знак `?`, а не 2 - `??`. Это необходимо для случаев, если все ваши паттерны ориентированы на 010 Editor 14 и более старые версии
6. `VERBOSE`
   - выводить лог работы патчера в окно Powershell. Без этого флага будут выводиться сообщения только из секций с Powershell и CMD-кодом
7. `CHECK_OCCURRENCES_ONLY`
   - только проверить наличие всех паттернов поиска для всех файлов из секций `patch_bin` и `patch_text` без выполнения замены. Другие секции (кроме секции с переменными для шаблона) не будут использованы
8. `CHECK_ALREADY_PATCHED_ONLY`
   - только проверить наличие всех паттернов замены для всех файлов из секций `patch_bin` и `patch_text` без выполнения замены
   - то есть в указанных файлах будет производиться поиск паттернов замены, а не паттернов поиска. При этом паттерны замены будут "скомбинированы"/дополнены до длины паттернов поиска, если они меньше длины, а также wildcard-символы в паттернах заменены реальными символами из паттернов поиска
   - другие секции (кроме секции с переменными для шаблона) не будут использованы
9. `EXIT_IF_NO_ADMINS_RIGHTS`
   - в самом начале работы патчера, при чтении секции с флагами, проверить наличие прав администратора у текущего выполняемого скрипта-патчера/процесса и если прав нет - завершить выполнение
10. `ASK_ADMINS_RIGHTS`
    - в самом начале работы патчера, при чтении секции с флагами, проверить наличие прав администратора у текущего выполняемого скрипта-патчера/процесса и если прав нет - запустить выполнение в новом процессе (с передачей тех же аргументов, что были переданы текущему скрипту) с запросом прав администратора
11. `SHOW_EXECUTION_TIME`
    - показать время/длительность работы патчера в конце. Этот флаг "неподвластен" флагу `VERBOSE` и даже если флаг `VERBOSE` будет отсутствовать, а данный флаг будет указан - время работы будет выведено в окно выполнения
12. `SHOW_SPACES_IN_LOGGED_PATTERNS`
    - при выводе информации о hex-паттернах - разделить пробелом каждый байт (то есть каждые 2 hex-символа), чтобы паттерн отображался, например, так: `00 A4 32 02 00 00 00 00 E0 5E B4 00 00 10 00 00`
13. `REMOVE_SPACES_IN_LOGGED_PATTERNS`
    - при выводе информации о hex-паттернах - удалить все пробелы в паттерне, чтобы паттерн отображался, например, так: `00A4320200000000E05EB40000100000`
14. `PATCH_ONLY_ALL_PATTERNS_EXIST`
    - сначала проверить, что все паттерны есть в указанных файлах и только потом выполнить их замену
    - если хотя бы 1 паттерн не найден - ни один файл не будет модифицирован
    - при этом поиск паттернов фактически производится 2 раза и это может быть критично, если файлы тяжелые и находятся на медленных HDD
15. `EXIT_IF_ANY_PATCH_BIN_FILE_NOT_EXIST`
    - при обработке секции `patch_bin` сначала будут проверены все строки в этой секции и для каждой строки, которая похожа на путь к файлу - будет выполнена проверка существования файла на диске
    - если хотя бы 1 файл не существует - обработка шаблона будет завершена с ошибкой
    - если все файлы существуют на диске - продолжится стандартная обработка этой и всех последующих секций
16. `EXIT_IF_ANY_PATCH_TEXT_FILE_NOT_EXIST`
    - при обработке секции `patch_text` сначала будут проверены все строки в этой секции и для каждой строки, которая похожа на путь к файлу - будет выполнена проверка существования файла на диске
    - если хотя бы 1 файл не существует - обработка шаблона будет завершена с ошибкой
    - если все файлы существуют на диске - продолжится стандартная обработка этой и всех последующих секций

---

2. `variables`

Здесь можно задать переменные, если какой-то кусок текста (например паттерн или путь к файлу) дальше в шаблоне нужно использовать несколько раз. Каждая новая переменная пишется с новой строки, сначала название переменной, потом знак `=`, потом данные привязанные к переменной.

Пример
`path_to_prog = C:\Users\Public\some folder again\program.exe`

Потом строка делится на 2 части по знаку `=` и производится `Trim()` обеих частей и далее в каждой секции будет производится поиск и замена имени переменной на ее значение. Поэтому указывайте имя уникальное для всего текста в шаблоне.

3. `pre_powershell_code`

Блок с Powershell-кодом который выполняется до применения hex-паттернов.

Здесь указывается код который будет помещен в отдельный файл `.ps1` и будет запущен. У функции, обрабатывающей эту секцию есть параметры `-hideExternalOutput` и `-needRunAS`. Добавив параметр `-hideExternalOutput` - весь стандартный поток вывода будет перенаправляться в `$null` (это сделано если вложенный скрипт имеет много текста для вывода в окно терминала и нужно скрыть этот текст), а параметр `-needRunAS` запускает этот скрипт с запросом прав Администратора. Если скрипт не будет перезапускаться с правами админа в отдельном процессе то результаты его работы будут выводится в текущем окне Powershell.

Текст из данной секции также подвергается анализу и замене переменных на их значения из секции переменных.

В случае возникновении ошибки или исключения при выполнении этого кода - обработка других секций шаблона будет прекращена.

4. `pre_cmd_code`

Блок с CMD-кодом который выполняется до применения hex-паттернов.

Здесь указывается код который будет помещен в отдельный файл `.cmd` и будет запущен. У функции, обрабатывающей эту секцию есть параметры `-hideExternalOutput` и `-needRunAS` и `-needNewWindow`.  Добавив параметр `-hideExternalOutput` - весь стандартный поток вывода будет перенаправляться в `$null` (это сделано если вложенный скрипт имеет много текста для вывода в окно терминала и нужно скрыть этот текст), а параметр `-needRunAS` запускает этот скрипт с запросом прав Администратора, а параметр `-needNewWindow` запускает скрипт в новом окне.

При этом если есть параметр `-needRunAS` и текущий скрипт-парсер не имеет прав админа, то созданный `.cmd`-скрипт в любом случае будет запущен в новом окне для запроса прав Администратора.

Текст из данной секции также подвергается анализу и замене переменных на их значения из секции переменных.

В случае возникновении ошибки при выполнении этого кода - обработка других секций шаблона будет прекращена.

5. `patch_bin`

Здесь располагаются пути к файлам и паттерны для для поиска + замены байт в hex-формате в файлах. Сначала идет строка - абсолютный путь к файлу. Следующие строки - паттерны для поиска+замены байт. Строки-паттерны могут быть как отдельная строка с байтами для поиска и отдельная строка для замены, либо строка может содержать оба паттерна, но они должны разделяться тем же самым разделителем, который используется при передаче паттернов в качестве аргументов к `ReplaceHexBytesAll.ps1`.

При обработке этой секции идет построчный анализ каждой строки и строка в этой секции может быть:
- путь к файлу
- паттерн поиска
- паттерн замены
- паттерн поиска + замены

Сначала идет строка - путь к файлу, а потом строки с паттернами. Соответственно после того как анализируемая в секции строка определяется как путь к файлу, все остальные строки считаются паттернами и "закрепляются" за этим файлом (то есть эти паттерны нужно будет применить к этому файлу), пока не будет найдена очередная строка - путь к файлу. В общем сначала идет поиск строки - пути к файлу, а все следующие строки анализируются как hex-паттерны пока не будет найдена очередная строка - путь к файлу.

Все эти данные (пути к файлам и паттерны) могут хранится в переменных шаблона и тут могут быть написаны только переменные.

Пути к файла могут содержать переменные окружения Windows, например `%temp%` или `%programfiles%` или `%appdata%` и т.д. Эти переменные будут корректно обработаны.

Если какого-либо файла из секции нет на диске, то обработка этого файла и паттернов для него пропускается без каких либо ошибок и секция анализируется дальше. Но если в шаблоне есть флаг `EXIT_IF_ANY_PATCH_BIN_FILE_NOT_EXIST` или `PATCH_ONLY_ALL_PATTERNS_EXIST`, то если хотя бы 1 файла нет на диске, то обработка всего шаблона завершится.

1. `patch_text`

Здесь располагаются пути к файлам и паттерны для для поиска + замены текста в файлах. Сначала идет строка - абсолютный путь к файлу. Следующие строки - паттерны для поиска+замены. Каждая строка в этой секции должна вмещать что-то одно - или путь или паттерн/строку/текст поиска или строку для замены.
Поддерживается поиск как регулярного выражения так и точного совпадения строки, а также регистрозависимый и регистронезависимый поиск для обоих вариантов.

При обработке этой секции идет построчный анализ каждой строки и строка в этой секции может быть:
- путь к файлу
- паттерн поиска
- паттерн замены

Сначала идет строка - путь к файлу, а потом строки с паттернами. Соответственно после того как анализируемая в секции строка определяется как путь к файлу, все остальные строки считаются паттернами и "закрепляются" за этим файлом (то есть эти паттерны нужно будет применить к этому файлу), пока не будет найдена очередная строка - путь к файлу. В общем сначала идет поиск строки - пути к файлу, а все следующие строки анализируются как hex-паттерны пока не будет найдена очередная строка - путь к файлу.

Все эти данные (пути к файлам и паттерны) могут хранится в переменных шаблона и тут могут быть написаны только переменные.

Пути к файла могут содержать переменные окружения Windows, например `%temp%` или `%programfiles%` или `%appdata%` и т.д. Эти переменные будут корректно обработаны.

Если какого-либо файла из секции нет на диске, то обработка этого файла и паттернов для него пропускается без каких либо ошибок и секция анализируется дальше. Но если в шаблоне есть флаг `EXIT_IF_ANY_PATCH_TEXT_FILE_NOT_EXIST`, то если хотя бы 1 файла нет на диске, то обработка всего шаблона завершится.

7. `hosts_remove`

Здесь указываются строки или URL-адреса которые должны быть удалены из файла `hosts`. Если строка секции начинается с символа комментария `#` или с `127.0.0.1` или с `0.0.0.0`, то будет производится поиск точно такой же строки, без учета длины пробелов. В противном случае предполагается что указан URL-адрес (например adobe.io), и строки содержащие такой адрес (такое слово, то есть текст и границами текста будут пробелы или переносы строк) будут удалены.

При этом можно указывать символ звездочки `*` и это будет значит регулярное выражение `.*` (до границ слова). То есть можно в секции написать строку с `*adobe*` и это приведен к удалению всех строк в которых содержится слово `adobe` с любыми символами, но если в секции будет строка `adobe` без звезд, то будут удалены строки которые содержат именно это слово без каких либо добавочных символов. Либо можно также указать `*adobe.io` и это удалит все строки с под доменами `adobe.io`

8. `hosts_add`

Здесь указываются строки которые необходимо добавить в файл `hosts`. Обычно добавляются строки, чтобы заблокировать доступ к каким-то URL-адресам, поэтому в этой секции можно просто написать URL-адреса (разумеется каждый на новой строке) и в `hosts` будет добавлена строка `0.0.0.0 <URL-адрес>` и это будет блокировать доступ к URL-адресу.

Если строка в секции начинается с `127.0.0.1` или с символа комментария `#`, то она будет добавлена в hosts без изменений. В противном случае строка считается непосредственным URL-адресом (например adobe.com) и в ее начало будет добавлено `0.0.0.0 ` что приведет к блокировке URL-адреса.

Функция по работе с этой секцией действует грамотно - если файла `hosts` не существует, то он будет создан. Если есть атрибут "Только чтение" то он будет снят перед изменение файла, а потом атрибут будет снова установлен. Если у скрипта нет прав Администратора для изменения файла - будет сформирована отдельная команда с текстом для добавления в `hosts` и она запустится в отдельном процессе Powershell с запросом прав админа.

Для этой секции есть "флаг" (индикатор/переключатель) - фраза `NOT MODIFY IT`. Если эта фраза будет в самом начале секции - все строки будут добавлены в `hosts` без изменений. Только `Trim()` будет применяться к строкам.

Если в секции для добавления первая строка содержит текст `SEE_HERE_FIRST`, а потом ссылку на список и ссылка действительно есть и она доступна для скачивания, то в hosts добавляем содержимое скачанное по ссылке, а не остальные строки в секции добавления. Например, первая строка может быть такой `SEE_HERE_FIRST https://a.dove.isdumb.one/list.txt`

9. `files_or_folders_delete`

Здесь указываются абсолютные пути к файлам и папкам которые необходимо удалить.

Функция по работе с этой секцией действует грамотно - если у файла есть атрибут "Только чтение" то он будет снят перед удалением, чтобы не было ошибок. Если для удаления каких-то файлов или папок нужны будут права администратора - все они будут сформированы в отдельный внутренний список и будет запущен отдельный Powershell процесс с запросом прав администратора который удалит все эти файлы и папки.

Для этой секции есть "флаг" (индикатор/переключатель) - фраза `MOVE TO BIN`. Если эта фраза будет в самом начале секции - все файлы и папки будут перемещаться в Корзину, а не удаляться из системы.

10. `file_create_from_text`

Здесь указываются данные для создания текстового файла. Первая строка секции - путь к файлу который необходимо создать и наполнить данными. Вторая строка может быть либо "флагом" (смотрите здесь ниже) либо уже началом текста который необходимо поместить в созданный файл. Если такой файл уже существует - сперва он будет удален. Далее идут строки с текстом которые будут помещены в созданный файл. Пустые строки не будут удаляться.

Для этой секции есть "флаг" (индикатор/переключатель) - фраза `CRLF`, либо `LF`. Если эта фраза будет во второй строке секции - это определит тип окончания строк в созданном текстовом файле. Если этого "флага" не будет, тип окончания строк будет такой же который используется при работе с текстом внутри скрипта, то есть `LF`.

11. `file_create_from_base64`

Здесь указываются данные для создания файла на основе расшифрованного base64 кода. Первая строка секции - путь к файлу который необходимо создать и наполнить данными. Если указанный в пути файл уже существует - сперва он будет удален. Вторая и последующие строки - единый блок base64-кода и этот код будет расшифрован и его содержимое помещено в файл (точнее файл будет состоять из содержимого - расшифрованного base64-кода).

12. `firewall_remove_block`

Здесь указываются абсолютные пути к файлам (очевидно это должны быть `.exe`-файлы) которые необходимо удалить из Windows Firewall. Предполагается что это будет выполняться для разблокировки доступа в интернет для программ для которых ранее доступ в есть был заблокирован.Будут удалены все правила фаервола для указанных путей, хотя, возможно, стоит добавить какие-либо параметры чтобы удалялись правила только блокирующие доступ в интернет.

Если необходимо применить удаление правил ко всем `.exe`-файлам в какой-то папке и всех вложенных папках, можно указать путь к этой папке и в конце путь должен заканчиваться текстом `\*`. Если необходимо сделать тоже самое но без вложенных папок, а только для 1 указанной папки, то путь должен заканчиваться `\*.exe`.

Для изменения параметров Windows Firewall однозначно нужны права администратора и если по каким-то причинам при работе этой функции этих прав у скрипта не будет - будет ошибка.

13. `firewall_block`

Здесь указываются абсолютные пути к файлам (очевидно это должны быть `.exe`-файлы) которым необходимо заблокировать доступ в сеть с помощью Windows Firewall.

Если необходимо заблокировать доступ к всем `.exe`-файлам в какой-то папке и всех вложенных папках, можно указать путь к этой папке и в конце путь должен заканчиваться текстом `\*`. Если необходимо сделать тоже самое но без вложенных папок, а только для 1 указанной папки, то путь должен заканчиваться `\*.exe`.

Для изменения параметров Windows Firewall однозначно нужны права администратора и если по каким-то причинам при работе этой функции этих прав у скрипта не будет - будет ошибка.

14. `registry_file`

Здесь указываются данные для модификации Windows Реестра. Абсолютно те же самые строки что пишутся в файлах `.reg` можно (нужно) писать здесь.

"Заголовок" в виде первой строки `Windows Registry Editor Version 5.00` можно не писать, он будет добавлен динамически, если его не будет в начале секции.

Если скрипт будет запущен без прав Администратора, то во временной папке будет создан файл `.reg` в который будут записаны эти данные. Потом будет запущен отдельный процесс Powershell с запросом прав администратора и в этом процессе выполнится команда импорта данных из этого файла в реестр Windows.

15. `post_powershell_code`

Блок с Powershell-кодом который выполняется после применения hex-паттернов.

Остальная информация такая же как в секции `pre_powershell_code`

16. `post_cmd_code`

Блок с CMD-кодом который выполняется после применения hex-паттернов.

Остальная информация такая же как в секции `pre_cmd_code`


## Известные ограничения

1. В секции `patch_text` в качестве строки/текста/паттерна поиска нельзя указывать то, что может быть распознано как существующий путь в коммандлете `Test-Path`
   - Даже строки типа `/Users` или `\/Users`, подробнее смотрите в документации по (Test-Path)[https://learn.microsoft.com/ru-ru/powershell/module/microsoft.powershell.management/test-path]
2. Код в секциях `pre_powershell_code` и `post_powershell_code` - полностью изолирован и не имеет доступа к функциям внешних/родительских скриптов.
   - Это связано с механизмом областей видимости в Powershell и чтобы Powershell-код мог видеть внешние переменные и функции придется и как-то пробросить окружение/контекст в этот код и я не нашел простых путей это реализовать

## Тестирование

Об этом в [отдельном файле](../tests/testing_RU.md)


## Утилиты

В папке [utilities](../utilities/) находятся файлы-скрипты созданные на основе функций из основных скриптов-утилит.

Файлы `.cmd` в этой папке содержат функции (или говоря по-другому - сделаны на основе функций) из файла [Start.cmd](../wrappers/data%20inside/Start.cmd). Созданы такие cmd-скрипты как:
- [Add URLs To Hosts](../utilities/AddURLsToHosts.cmd)
- [Block With Firewall](../utilities/BlockWithFirewall.cmd)

Думаю названия файлов явно говорят что делают эти скрипты. Текст/строки/данные с которыми работают скрипты - находятся внутри самих скриптов, поэтому чтобы добавить/изменить URL-адреса для добавления в hosts - вам нужно изменить 1 переменную в скрипте [AddURLsToHosts.cmd](../utilities/AddURLsToHosts.cmd) добавив в нее список адресов.

Чтобы изменить или добавить пути к файлам которые необходимо заблокировать с помощью Windows Firewall - вам необходимо в скрипте [BlockWithFirewall](../utilities/BlockWithFirewall.cmd) добавить/изменить переменные `target_path_1` изменяя счетчик-цифру в конце переменной, а потом в переменной `count_target_files` изменить цифру которая обозначает общее количество этих переменных.
Каждая такая переменная может хранить либо абсолютный путь к exe-файлу, либо путь к папке в которой необходимо заблокировать все exe-файлы. Путь к папке обязательно должен заканчиваться `\*.exe`, например `D:\TEMP\test\sub folder\*.exe` и тогда будут заблокированы все exe-файлы только в этой папке. Если необходимо рекурсивно заблокировать exe-файлы во всех подпапках, то нужно задать значение "TRUE" для переменной `USE_SUBFOLDERS` ниже в коде.

Файлы `.ps1` в этой папке содержат функции (или говоря по-другому - сделаны на основе функций) из файла [Parser.ps1](../wrappers/data%20in%20template/Parser.ps1). Созданы такие Powershell-скрипты как:
- [Add URLs To Hosts](../utilities/AddURLsToHosts.ps1)
- [Remove URLs From Hosts](../utilities/RemoveURLsFromHosts.ps1)
- [Block With Firewall](../utilities/BlockWithFirewall.ps1)
- [Remove Rules From Firewall](../utilities/RemoveRulesFromFirewall.ps1)

Думаю названия файлов явно говорят что делают эти скрипты. Текст/строки/данные с которыми работают скрипты - находятся внутри самих скриптов, в самом верху файлов. Тип данных абсолютно такой же как в файле `template.txt`, просто эти данные нужно будет вручную написать в самих скриптах.


## Ответы на возможные вопросы

1. Почему так много кода?
    - У меня не много опыта в написании кода. А код на Powershell и CMD я пишу впервые
    - Я старался сделать проект монолитным, чтобы на компьютер на котором необходимо выполнять модификации можно было перенести всего пару файлов, включая шаблон и просто запустить "исполняемый файл" двойным кликом
    - Я старался добавлять разнообразные проверки (например на существование пути к файлу или на то) везде где считал нужным, а это много где. Вероятно не везде нужны эти проверки. Особенно если продумать архитектуру проекта и привести ее в нормальный вид.
    - У меня было желание, (хотя, скорее всего, это личный спортивный интерес) сделать так, чтобы скрипт можно было запускать и выполнять без прав администратора и эти права запрашивались только тогда, когда они нужны. Из-за этого пришлось добавлять и обрабатывать проверки нужны ли права администратора для данной операции и запускать отдельный Powershell-код (в том числе многострочный) в отдельных процессах с запросом прав администратора. Если убрать все эти проверки и проверять наличие прав только в самом начале - код похудеет на 1/5 часть, наверное.
2. Почему шаблон не в формате JSON или XML?
    - Потому что я отталкивался от идеи того, что я смогу просто в текстовом файле написать путь и ниже вставить hex-паттерны из заметок по патчу этого файла.
    - Потому что эти типы структур файлов имеют довольно строгий формат разметки и при заполнении файла вручную, писать и форматировать текст в структуре JSON или XML было бы сложно. Я делал структуру шаблона такой, которая прощает ошибки и менее строгая, в отличии от JSON и XML.
3. Можно ли используя поиск и замену байт - удалить последовательность байт?
    - Да, но для этого необходимо немного модифицировать код. Это добавлено в список задач в TODO-листе в Readme.
    - Данный проект (патчер с поиском и заменой байт) нацелен, в основном, на патч бинарных файлов. В моей практике (в моих задачах) применяется только замена байт. Удаление байт из бинарного файла, в большинстве случаев, приводит к тому, что файл становится битым (сломанным, не рабочим), по крайней мере в исполняемых файлах и файлах-библиотеках. Удалять байты в бинарных файлах, наверное, имеет смысл только если необходимо удалить какую-то мета-информацию, например цифровую подпись которая, обычно, располагается в конце exe-файлов.
4. Как помочь проекту?
    - Выполнить то, что написано в TODO (не ухудшив функциональность и производительность кода)
    - Провести рефакторинг и улучшение производительности кода/утилиты
    - Или найти того кто это сделает
5. Почему нет функций `Replace()`? Что делают функции `OverWrite()`?
    - Потому что изменилась концепция и подход к модификацию файлов.
    - Само слово "replace" и процедура замены последовательности байт означает, что при использовании паттерна `11223344/AABB3344` будем искать последовательности `11223344` и эти последовательности полностью заменять на другую последовательность - `AABB3344`. А что, если нам нужно заменить последовательность `11223344` на `AA`?
    - Функции `Replace()` реализованные в проекте на момент написания этого текста - не могут такое сделать (потому что необходимо будет разбивать файл на части и "сшивать" его в местах разрыва, чтобы изменилась длина файла. Необходимость таких замен в исполняемых файлах я никогда не встречал, потому что изменение размера исполняемого файла при вет к его неработоспособности). Функции `Replace()` могут менять только последовательности одинаковой длины. То есть функция замены последовательностей байт не может по факту выполнить любую замену последовательностей.
    - По факту такие функции `Replace()` находят участки совпадающие с паттернами поиска и в этих участках начиная с первого байта выполняют вставку байт из паттерна замены с перезаписью байт (то есть не вставку байт между другими, а именно с перезаписью). Это не замена байт.
    - Поэтому семантически правильно называть такие функции как "поиск адресов паттернов поиска с вставкой паттернов замены с перезаписью". Говоря проще - `OverwriteBytesAtPatternPositions()`
    - Почему тогда в названии проекта фигурирует слово "Replace" и часто говорится про замену байт, а не вставку с перезаписью в найденные позиции? Потому что фраза "поиск и замена байт", на мой взгляд, это исторически устоявшееся выражение и большинство инструментов hex-патчей делают именно поиск и замену байт (например `perl` или `sed`) и в большинстве случаев делают это только при условии, что паттерны поиска и замены - одинаковой длины
6. Если у меня есть только паттерны поиска и я хочу проверить есть ли они в определенных файла - я могу это сделать с помощью данной утилиты?
    - Да, но т.к. представленные инструменты предназначены для работы с паттернами поиска + замены - вам необходимо будет добавить паттерны замены к вашим паттернам поиска. hex-паттерны замены в данном случае могут быть абсолютно любыми, например просто hex-значение `00`
    - Разумеется вам также нужно будет использовать соответствующий аргумент или флаг шаблона. Если вам нужно выполнить только поиск с помощью скрипта-ядра `ReplaceHexBytesAll.ps1`, то используйте аргумент `-onlyCheckOccurrences`, а если вы используете обертку типа "data in template" то в шаблон добавьте флаг `CHECK_OCCURRENCES_ONLY`
7. Зачем нужен файл `build.cmd`? Мне нужно что-то компилировать?
    - Компилировать ничего не нужно и выполнять сборку или установку зависимостей - тоже не нужно. Файл `build.cmd` необходим только при тестировании написанного в файле `HexHandler.cs` - C# кода.
    - Если запустить `build.cmd`, то он выполнит компиляцию файлов `Launcher.cs` и `HexHandler.cs` в той же папке в файл `HexTool.exe`. Если компиляция произошла и exe-файл создался, значит в C#-коде нет ошибок.
    - То есть данный файл используется исключительно для проверки наличия ошибок в C#-коде посредством его компиляции. 
8. Могу ли я воспользоваться
    - Компилировать ничего не нужно и выполнять сборку или установку зависимостей - тоже не нужно. Файл `build.cmd` необходим только при тестировании написанного в файле `HexHandler.cs` - C# кода.