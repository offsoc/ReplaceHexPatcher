# Дополнительная информация

Language: Русский | [English](additional_info_EN.md)

- [Дополнительная информация](#дополнительная-информация)
  - [Небольшие личные выводы](#небольшие-личные-выводы)
    - [О CMD](#о-cmd)
    - [Адаптивный перезапуск с правами админа (UAC) - это очень большой геморрой](#адаптивный-перезапуск-с-правами-админа-uac---это-очень-большой-геморрой)
    - [О Powershell](#о-powershell)
  - [Полезности](#полезности)
    - [Репозитории с примерами грамотных скриптов](#репозитории-с-примерами-грамотных-скриптов)
    - [Реализации поиска hex-паттернов на C#](#реализации-поиска-hex-паттернов-на-c)


Здесь будет информация/заметки, которые не относятся напрямую к данному репозиторию/утилите/инструменту, но связаны с этапами разработки.


## Небольшие личные выводы

Это мой первый опыт написания скриптов на CMD (batch) и Powershell. Учитывайте это при чтении моих выводов.

### О CMD

**CMD это боль!**

И вот почему:
- нет нормальных функций
  - конструкции `call` необходимо обязательно помещать в конце файла, иначе при выполнении кода эти блоки также будут прочитаны и выполнены, они никак не огорожены, просто на них есть "ссылка" 
- нет нормальных циклов
  - чтобы сделать циклы необходимо делать условия в которых есть `goto` на метку вне/перед условием
- повторное оборачивание чего-либо в кавычки - добавляет эти кавычки в оборачиваемое значение и из-за этого часто возникают проблемы и это приходится держать в голове
- нет нормального способа хранить любой многострочный текст
  - если в многострочном тексте нет кавычек и некоторых спец. символов, то такой текст можно хранить в многострочном виде, но если есть кавычки и спец. символы то приходится перед каждой строкой добавлять `echo `

Основной плюс из-за которого стоит рассматривать написание чего-либо на CMD - это то, что его можно запустить 2-м кликом в любой Windows. (Конечно есть еще VBS но он как-то менее распространен)

### Адаптивный перезапуск с правами админа (UAC) - это очень большой геморрой

Если делать утилиту "по феншую", то права администратора необходимо запрашивать только когда без них точно не обойтись.

Также стоит помнить про атрибут "только для чтения", потому что если у файла стандартные права то этот атрибут можно снять без проблем без запроса прав администратора, хотя тест на попытку записи покажет что нужны права админа для изменения файла.

Жонглирование этими 2мя пунктами "права администратора" и атрибут "только для чтения" довольно запутанная задача и это добавляет довольно много дополнительной логики в скрипт и уменьшает читаемость кода.

Особенно это является проблемой когда из обычного Powershell-скрипта необходимо запустить код который содержит многострочный текст.
Намного проще и удобнее запросить права администратора в самом начале выполнения скрипта и прервать выполнение при их отсутствие, но не факт что эти права действительно необходимы для внесения изменений.

True-путь это запрашивать права при необходимости.

Позже логика запросов прав администратора в скрипте-патчере была изменена и проверка необходимости перезапуска с запросом прав администратора делается с самого начала, потому что у файла могут отсутствовать разрешения на чтение и чтобы банально прочитать файл и произвести поиск байт (без замены байт, то есть без изменения файла) могут понадобится права Администратора. Эта изначальная проверка позволила уменьшить количество "костылей" в принципе количество кода в патчере.

### О Powershell

Powershell показал себя с хорошей стороны и является хорошей альтернативой Unix Shell.

Естественно, сравнивать CMD и Powershell это тупо, это совсем разные "уровни", это как сравнивать небо и землю.

Но без недостатков не обошлось. И вот какие они:
- `.ps1` скрипты нельзя запустить двойным кликом, в отличие от Unix Shell-скриптов в Unix-системах и в отличие от `.cmd` или `.bat` или `.vbs` файлов в Windows. Придется писать скрипт-обертку `.cmd` для запуска `.ps1`, если нужен запуск по двойному клику.
- Типизация фиктивная - интерпретатор нигде не проверяет соответствие переменной указанному ей типу. Похоже типизация применяется только в IDE для авто дополнения.
- Нет хороших IDE (я не нашел).
  - Windows Powershell ISE - выглядит старомодно и топорно и лично мне в ней не комфортно писать большой код и нет множества удобных функций, по сравнению с Visual Studio Code.
  - Visual Studio Code по началу казалась безупречной альтернативой "ISE" для написания кода Powershell, но в VSC почему-то авто дополнение работает странно (или не работает совсем) в некоторых моментах - когда начинаю набирать слова `break` или `continue` то автодополнение не подсказывает продолжение этих слов, значит есть и другие аналогичные ситуации.
  - Может в IDE от JetBrains все идеально при написании кода на Powershell, но я это не проверял.
- Возврат значения в "никуда" в самом скрипте - вернет значение в поток вывода.
  - Это немного странное поведение и если о нем не знать или забыть учесть этот нюанс - можно потратить много времени на дебаг. А именно при выполнении функций `New-Item` и функции `.Add()` у `ArrayList` - эти функции возвращают значение. Если [не присвоить](https://stackoverflow.com/a/46586504) то значение - оно попадет в поток вывода, то есть смешается с тем что будет передаваться в `Write-Host`.
- Есть странная ситуация при которой производительность скрипта падает в 3 раза (он работает в 3 раза дольше)
  - Я пытался отрефакторить одну функцию и вынес инициализацию переменной с массивом байт за пределы функции где эта переменная используется. [Код до](https://gist.github.com/Drovosek01/9d47068365ea0bce26526ee61b23be7c?permalink_comment_id=5141498#gistcomment-5141498) и [код после](https://gist.github.com/Drovosek01/9d47068365ea0bce26526ee61b23be7c?permalink_comment_id=5141499#gistcomment-5141499). И просто при выносе массива байт за пределы переменной скрипт стал работать в 3 раза медленнее. Это очень странно.
- Нет "нативного" пути (я не нашел такой) переместить файл в Корзину.
  - Чтобы переместить файл в Корзину - необходимо будет использовать компоненты из Visual Basic Script или JScript.
- Нет способа (я не нашел) проверить нужны ли права администратора для удаления папки [без попытки ее удаления](https://qna.habr.com/q/1364540)
- Блок `catch {}` после `try {}` ловит не все ошибки
  - Например если при выполнении `New-Item` или `Remove-Item` будет ошибка, то без аргумента `-ErrorAction Stop` блок `catch {}` не поймает ошибку
- Обработка (например поиск) байт непосредственно "силами Powershell" работает ощутимо медленней, чем в скомпилированных версиях алгоритмов, если после каждого найденного байта необходимо выполнять дополнительные проверки. Чем больше конструкций `if {...}` выполняется после нахождения нужного байта - тем медленнее работает скрипт. Это очень ощутимо, при поиске небольших паттернов, например поиск `00000090` и замена на `11223344` - попробуйте сделать это с помощью [стратегии v4](../core/search%20strategies/SearchReplaceBytes_v4.ps1) (в которой нет поддержки wildcards) и с помощью [стратегии v4.1](../core/search%20strategies/SearchReplaceBytes_v4.1.ps1) (в которой есть поддержка wildcards `??` и, соответственно, дополнительные условия сравнений) и вы заметите разницу в скорости работы.
  - Поэтому бизнес-логику поиска и замены байт лучше написать на C# и в Powershell-скрипте автоматически компилировать этот C#-код и импортировать его в скрипт и выполнять обработку с помощью скомпилированного компонента, а не с помощью "сил Powershell". Это заметно улучшит скорость работы утилиты.
  - Возможно в Powershell Core ситуация лучше, но в Powershell 5.1, который идет "из коробки" в Windows 10 - скорость работы скрипта сильно отличается от аналогичного когда скомпилированного на C#.
- Вероятно из-за не строгой типизации (или ее отсутствия) не возникает ошибок там, где они должны быть, например при попытке получить элемент массива по индексу, который указывает за пределы массива. Если это не заметить (и не писать дополнительные условия проверки индексов), то привыкаешь к этому, а потом при портировании кода на языки с нормальной типизацией (например C#) - возникают ошибки и можно долго искать ошибку в коде. Хотя прямое портирование с Powershell на C# было выполнено правильно.
- В Powershell если функция возвращает массив с 1 элементом (например число -1), то Powershell автоматически "распаковывает" этот массив и возвращает этот единственный элемент из массива, а не массив с 1 элементом.
- Примеры из интернета и вроде бы логичный код - может не работать. Например такие примеры кода:
  - `irm https://github.com/Drovosek01/ReplaceHexPatcher/raw/refs/heads/main/core/v2/ReplaceHexBytesAll.ps1 | iex`
  - `& ([scriptblock]::Create((Invoke-RestMethod -Uri "https://github.com/Drovosek01/ReplaceHexPatcher/raw/refs/heads/main/core/v2/ReplaceHexBytesAll.ps1")))`
  - `$url="https://github.com/Drovosek01/ReplaceHexPatcher/raw/refs/heads/main/core/v2/ReplaceHexBytesAll.ps1"; $f=[System.IO.Path]::GetTempFileName()+".ps1"; (irm $url)>$f; & $f`
  - В итоге, как оказалось, Powershell зачем-то автоматически конвертировал кодировку в `UTF-16 LE` и сохранял файл с этой кодировкой (и размер сохраненного файла увеличивался в 2 раза), хотя в оригинальном файле кодировка `UTF-8 with BOM`
- Экранирование в Powershell сделано "не по канону", то есть для экранирования нужно использовать не обратный слэш `\`, а апостроф "`"
- Окно Powershell при выборе файлов через дополнение через клавишу Tab - иногда пишет имена файлов как они есть в Проводнике, а иногда экранирует специальные символы 
  - Например может экранировать квадратные скобки апострофами `D:\TEMP\My Best App [Win] for test.7z` (тут в примере апострофы вставить не получилось потому что в Markdown они не экранируются)
  - И почти во всех командлетах, которые работают с файловой системой, реестром и т.д. (например `Test-Path`, `Resolve-Path`, `Get-Item` и много других) есть дополнительные аргументы, чтобы полученный ранее путь использовать в командлете "как есть" (аргумент `-LiteralPath`), а можно полученный путь использовать как регулярное выражение (когда просто передаем строку без аргументов) и тогда квадратные скобки будут рассматриваться как команда регулярки и путь не будет найден
  - Но C# функции (например открытие стрима файла используя `[System.IO.File]::Open()`) не поддерживают экранирование из Powershell и при передачи пути в эти функции необходимо удалить экранирование
  - А также при обычном сравнении строк оператором `-eq` квадратные скобки и другие спец. символы рассматриваются как часть строки, а не как часть регулярки
  - **Поэтому, чтобы покрыть все варианты использования путей** переданных в скрипт в качестве аргументов - необходимо из полученного пути удалить все экранирование и во всех командлетах, в которые передается такой путь - не забыть добавлять аргумент `-LiteralPath`. Либо наоборот - сохранить и использовать путь с экранированием, а в условиях и C#-функциях предварительно обрабатывать строку с путем, удаляя из нее экранирование
  - Это ощутимый геморрой и добавляет дополнительный "слой жонглирования"


## Полезности

### Репозитории с примерами грамотных скриптов

Скрипты на Powershell
- https://github.com/KurtDeGreeff/PlayPowershell
- https://www.robvanderwoude.com/

Скрипты на CMD/Bat
- https://github.com/npocmaka/batch.scripts
- https://github.com/corpnewt/ProperTree/blob/master/ProperTree.bat
- https://stackoverflow.com/a/45070967

### Реализации поиска hex-паттернов на C#

В качестве отдельных функций
- https://www.cyberforum.ru/csharp-net/thread1946246.html
- https://stackoverflow.com/questions/4859023/find-an-array-byte-inside-another-array
- https://stackoverflow.com/questions/16252518/boyer-moore-horspool-algorithm-for-all-matches-find-byte-array-inside-byte-arra
- https://forum.cheatengine.org/viewtopic.php?p=5726618
  - https://stackoverflow.com/questions/44314769/using-boyer-moore-algorithms-in-64-bit-processes
- https://stackoverflow.com/questions/28329974/byte-pattern-finding-needle-in-haystack-wildcard-mask
- https://stackoverflow.com/a/50625581/8744985

В составе утилит
- https://github.com/jjxtra/HexAndReplace/
- https://github.com/Haapavuo/HexPatcher/