# Список задач

Language: Русский | [English](todo_EN.md)

- [Список задач](#список-задач)
  - [ToDo](#todo)
    - [Разное](#разное)
    - [Парсер шаблона](#парсер-шаблона)
    - [Только ядро поиска и замены](#только-ядро-поиска-и-замены)
    - [Вывод информации](#вывод-информации)


Здесь находится список функций, которые специфичны и я могу их забыть реализовать.

## ToDo

### Разное

- [ ] Добавить способ разблокировки файлов-целей, если они заблокированы другим `fileStream.Read()` или используются где-то
- [ ] Найти нормальный способ проверить нужны ли права администратора для удаления папки
  - Текущий способ проверяет это путем создания и удаления пустого файла в необходимой папке (это неправильно с точки зрения логики и производительности, но в большинстве ситуаций это работает как надо)

### Парсер шаблона

- [ ] Реализовать считывание паттернов из файла в самом патчере
- [ ] Реализовать чтение шаблона из base64-кода
  - Как в случае, если это файл с base64-кодом, там и строка-аргумент
- [ ] Добавить секции с `pre-cmd` и `pre-powershell` кодом и с `post-cmd` и `post-powershell` кодом
  - Код в секциях должен выполняться до и после выполнения патча в соответствии с названиями секций
  - Если выполнение кода секции завершилось с ошибкой - прервать работу патчера
- [ ] Добавить поддержку [глоббинга](https://stackoverflow.com/questions/30229465/what-is-file-globbing) в строки с путями к файлам/папкам, которые необходимо найти, в файле-шаблоне
- [ ] Добавить поддержку работы с относительными путями
   - Имеется ввиду пути файлов в шаблоне
- [ ] В секции для удаления файлов и папок добавить поддержку удаления только всех вложенных данных или вложенных файлов по какому-то паттерну (например `\*exe`), хотя наверное это и есть глоббинг
- [ ] Возможно стоит добавить логику запуска `.ps1` файлов от имени администратора в скрипте-парсере
   - Имеется ввиду файлы создаваемые из кода в шаблоне
- [ ] Заменить текущий способ перезапуска патчера с запросом прав администратора
  - Текущий способ ощутимо громоздкий и добавляет много сложно читаемого кода
  - Стоит заменить его на проверку возможности чтения файла, а возможность перезаписи файла, наверное, лучше реализовать в C#-ядре, потому что там происходит изменение файла

### Только ядро поиска и замены

- [x] Переписать ядро на C#
- [x] Реализовать перегрузки всех функций, в которые передаются паттерны
  - Чтобы паттерны можно было передавать как в виде строки, так и в виде массива байт, тк и массива байт и массива-маски для wildcard символов
- [x] Реализовать поддержку поиска с wildcard `??` в паттернах как в [AutoIt](https://www.autoitscript.com/autoit3/docs/functions/StringRegExp.htm) или в [010 Editor](https://www.sweetscape.com/010editor/manual/Find.htm) или в [Frida Memory scan](https://frida.re/docs/javascript-api/#memory)
  - [x] Wildcard в паттернах поиска
  - [x] Wildcard в паттернах замены
  - [x] В функциях должна быть проверка наличия в паттернах поиска и замены - wildcard символов. Если паттерны без wildcard-символов, то должны использоваться функции без поддержки wildcards. Потому что в функциях с поддержкой wildcards - больше условий и проверок на каждой итерации и они работают медленнее, чем функции без поддержки wildcards (но это лишь гипотеза).
- [x] Реализовать функции StartsWith и EndsWith для проверки, что файл начинается или заканчивается указанным набором байт
- [x] Реализовать оптимизации поиска для ускорения поиска
  - [x] Оптимизация поиска в случае, когда паттерн поиска начинается с wildcard-символов или заканчивается ими
    - В случае когда паттерн-поиска начинается с wildcard-символов - нужно найти первый обычный (не-wildcard) байт и искать его, а при поиске сделать отступ от начала файла в длину между началом паттерна поиска и первым обычным байтом. Иначе поиск wildcard-символа превратится в последовательный перебор вообще всех байт файла
    - В случае, когда паттерн-поиска заканчивается wildcard-символами, то их искать не нужно, достаточно будет проверить, что с текущего индекса последнего обычного байта в паттерне и до конца файла - байтов больше, чем wildcard-символов до конца паттерна
  - [x] Оптимизация поиска, когда паттерн поиска начинается последовательностью одинаковых символов
    - В случае, когда паттерн поиска начинается с последовательности одинаковых символов (например в паттерне поиска первые 10 байт это нулевые байты), то необходимо как-бы "виртуально удалить" все дубликаты байт в начале (то есть удалить 9 нулевых байт), оставив только 1 байт из последовательности одинаковых. Когда будет найден этот байт, необходимо будет проверить, что перед ним 9 таких же байт, как он сам.
    - Не уверен, что это ускорит работу при использовании паттернов с последовательностью одинаковых байт в начале, поэтому обязательно необходимо провести грамотные тесты и проверки производительности с такой оптимизацией
- [ ] Реализовать проверку наличия прав на изменение/перезапись файла сразу после первого найденного паттерна, а не после перебора всех паттернов в основном скрипте
- [ ] Перенести часть функционала из `ReplaceHexBytesAll` в код на C#
  - Рассмотреть возможность переноса как в отдельные классы, так и в класс `BytesHandler`
- [ ] Реорганизовать/переписать/разделить код ядра на разные файлы в ООП-стиле
  - Например как [тут](https://github.com/Invertex/BinaryFilePatcher/blob/master/BinaryFilePatcher/BinaryFilePatcher.cs)
- [ ] Реализовать поддержку регулярных выражений в hex-шаблонах как в `sed` или `perl`
  - Возможно [этот](https://stackoverflow.com/a/55314611) пример поможет
- [ ] Реализовать поиск с помощью алгоритма Boyer-Moore-Horspool
  - [ ] Сравнить скорость работы текущего алгоритма с алгоритмом Boyer-Moore-Horspool
  - Ссылки на примеры реализованных функций поиска этим алгоритмом есть в [файле](./additional_info_RU.md#реализации-поиска-hex-паттернов-на-c) с дополнительной информацией
- [ ] Реализовать поддержку удаления из файла найденных hex-паттернов
- [ ] Реализовать функцию поиска hex-паттерна начиная с определенного смещения в файле или начиная с определенной части файла в %
- [ ] Реализовать поддержку указания индексов замен найденных шаблонов (если нужно заменять не все найденные последовательности)
- [ ] Разобраться стоит ли хранить C# код внутри Powershell-скрипта в виде zip-архива в base64 или cab-архива
  - Это поможет уменьшить размер Powershell-скрипта на 10-20 Килобайт, но, вероятно, увеличит длительность его работы, потому что, чтобы скомпилировать C#-код нужно будет сначала раскодировать base64-строку, а потом распаковать полученный zip-архив или cab-архив
  - Скорее всего это не нужно
- [ ] Добавить функционал работы с PE-заголовками
  - https://chentiangemalc.wordpress.com/2021/02/24/parsing-pe-files-in-powershell/
  - https://github.com/secana/PeNet
- [ ] Реализовать нативную утилиту вычисления CRC32
  - Стоит рассмотреть C#-код из других проектов:
  - https://damieng.com/blog/2006/08/08/calculating_crc32_in_c_and_net/
    - https://github.com/damieng/DamienGKit/blob/master/CSharp/DamienG.Library/Security/Cryptography/Crc32.cs
  - https://github.com/zoltraks/csharp-crc32/blob/main/src/Crc32/Crc32.cs
  - https://forums.mydigitallife.net/threads/c-calculating-crc32-hash-from-any-file-or-string.29306/
  - https://staceyw1.wordpress.com/2005/06/09/crc32-in-c/
  - Возможно в новых версия C#/.NET уже есть реализация вычисления CRC32 - https://learn.microsoft.com/ru-ru/dotnet/api/system.io.hashing.crc32

### Вывод информации

- [ ] Стилизовать прогресс-бары
  - При поиске Firewall-правил с указанными путями к exe - появляется прогресс бар отображающий прогресс выполнения процесса. Он появляется в верху терминала просто с названием метода `Get-NetFirewallRule`
- [ ] Добавить уровни логирования
  - Возможно это лучше регулировать с помощью флага в секции флагов
